<script type="text/html" data-template-name="multi device out">
  <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="multi-device-out.label.name"></label>
      <input type="text" id="node-input-name">
  </div>
  <div class="form-row">
      <label for="node-input-device_source"><i class="fa fa-gears"></i> <span data-i18n="multi-device-out.label.action"></label>
      <select id="node-input-device_source" onchange="nodeDeviceOut_displayDeviceSourceElement()">
          <option value="self" data-i18n="multi-device-out.text.triggered"></option>
          <option value="configured" data-i18n="multi-device-out.text.specific"></option>
          <option value="dynamic" data-i18n="multi-device-out.text.defined"></option>
      </select>
  </div>
  <div class="form-row" id="node-input-dynamic">
      <label for="node-input-devices_source_dynamic" id="node-input-devices_source_dynamic_label"><i class="fa fa-tag"></i> <span data-i18n="multi-device-out.label.attribute"></label>
      <input type="text" id="node-input-devices_source_dynamic" data-i18n="[placeholder]multi-device-out.text.enter_attribute" />
      <input type="hidden" id="node-input-devices_source_dynamicFieldType">
  </div>
  <div class="form-row" id="node-input-configured">
      <label for="form-row node-input-rule-container-row" id="node-input-devices_source_configured_label"><i class="fa fa-wifi"></i> <span data-i18n="multi-device-out.label.devices"></label>
      <div class="form-row node-input-rule-container-row">
          <ol id="node-input-rule-container"></ol>
      </div>
      <datalist id="node-input-list_devices_id"></datalist>
  </div>
  <div class="form-row">
      <label for="node-input-attrs"><i class="fa fa-cube"></i> <span data-i18n="multi-device-out.label.source"></label>
      <input type="text" id="node-input-attrs" />
      <input type="hidden" id="node-input-msgFieldType">
  </div>
</script>

<script type="text/x-red" data-help-name="multi device out">
  <p>Set a new value for a device, based on the results operations on the flow.</p>
  <p>
    Device out will determine which device (or devices) will have its attributes
    updated on dojot according to the result of the flow. Bear in mind that this
    node doesn’t send messages to your device, it will only update the attributes
    on the platform. Normally, the chosen device out is a virtual device, which
    is a device that exists only on dojot.
  </p>

  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt class="mandatory">Name <span class="property-type">optional</span></dt>
    <dd>Name of the node</dd>
    <dt class="mandatory">Actions <span class="property-type">required</span></dt>
    <dd>
      Which device will receive the update. Options are:
      <ul>
        <li>
          <u>The device that triggered the flow</u>: this will update the same device
          that sent the message which triggered this flow.
        </li>
        <li>
          <u>Specific device(s)</u>: which device(s) that will receive the update.
        </li>
        <li>
          <u>Device(s) defined during the flow</u>: which device(s) which device(s) that will receive the
          update. This is referenced by a list of values, just as with output
          values (msg.list_of_devices).
        </li>
      </ul>
    </dd>
    <dt class="mandatory">Device <span class="property-type">required</span></dt>
    <dd>
      Select “The device that triggered the flow” will
      make the device that was the entry-point be the end-point of the flow.
      “Specific device” any chosen device wil be the output of the flow and “a
      device defined during the flow” will make a device that the flow selected
      during the execution the endpoint.
    </dd>
    <dt class="mandatory">Source <span class="property-type">required</span></dt>
    <dd>
      Data structure that will be mapped as message to
      device out
    </dd>
  </dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
      <dd>The device will be updated by its <strong>Source</strong> attribute with the received value from the flow.</dd>
  </dl>
</script>

<script type="text/javascript">
  RED.nodes.registerType("multi device out", {
    category: "output", // the palette category
    defaults: {
      // defines the editable properties of the node
      name: { value: "", required: false },
      device_source: { value: "self", required: true },
      devices_source_dynamic: { value: "", required: false },
      devices_source_dynamicFieldType: { value: "msg" },
      devices_source_configured: { value: [""], required: false },
      attrs: { value: "", required: true },

      // private
      _devices_loaded: { value: false, required: false },
    },
    inputs: 1, // set the number of inputs - only 0 or 1
    outputs: 0, // set the number of outputs - 0 to n
    align: "right", // align the icon
    icon: "bridge-dash.png", // set the icon (held in icons dir below where you save the node)
    color: "#f3b567", // background-color
    label: function () {
      // sets the default label contents
      return this.name || RED._("multi device out");
    },
    labelStyle: function () {
      // sets the class to apply to the label
      return this.name ? "node_label_italic" : "";
    },
    paletteLabel: "multi dev out",
    oneditprepare: function () {
      let node = this;
      let listDevices = $("#node-input-list_devices_id");
      nodeDeviceOut_displayDeviceSourceElement();

      if (!this.devices_source_dynamicFieldType) {
        this.devices_source_dynamicFieldType = "msg";
      }
      $("#node-input-devices_source_dynamic").typedInput({
        default: "msg",
        types: ["msg"],
        typeField: $("#node-input-devices_source_dynamicFieldType"),
      });

      $("#node-input-attrs").typedInput({
        default: "msg",
        types: ["msg"],
        typeField: $("#node-input-msgFieldType"),
      });

      // request to the device manager all devices
      function list_all(page) {
        return new Promise((resolve, reject) => {
          if (page === undefined) {
            page = 1;
          }

          var extra = `?page_size=999999&page_num=${page}`;
          var orderByLabel = "sortBy=label";

          extra += "&" + orderByLabel;

          DojotService.getDevices(extra)
            .then((list) => {
              list.data.devices.map((dev) => {
                listDevices.append(
                  '<option data-value="' +
                    dev.id +
                    '" value="' +
                    dev.label +
                    " (" +
                    dev.id +
                    ')"/>',
                );
              });
              if (list.data.pagination.has_next) {
                return list_all(list.data.pagination.next_page).then(() => {
                  return resolve();
                });
              } else {
                node._devices_loaded = true;
                return resolve();
              }
            })
            .catch((error) => {
              console.error(
                "Failed to retrieve the list of available devices",
                error,
              );
              node._devices_loaded = false;
              return reject();
            });
        });
      }

      $("#node-input-device_source").css("width", "70%");

      list_all()
        .then(() => {
          // define the rule box
          $("#node-input-rule-container")
            .css("min-height", "150px")
            .css("min-width", "450px")
            .editableList({
              addItem: function (container, index, data) {
                let fieldConfig = {
                  type: "text",
                  list: "node-input-list_devices_id",
                  id: `node-input-device_source_id`,
                  placeholder: RED._(
                    "dojot/multi-device-out:text.select_device",
                  ),
                };

                if (Object.entries(data).length > 0) {
                  let configuredDeviceEntry = $(
                    "#node-input-list_devices_id",
                  ).find('option[data-value="' + data + '"]');
                  if (configuredDeviceEntry) {
                    fieldConfig.value = configuredDeviceEntry.attr("value");
                  } else {
                    fieldConfig.value = `Missing device: ${data}`;
                  }
                }

                $("<input/>", fieldConfig).appendTo(container);
              },
              sortable: true,
              removable: true,
            });

          // load the previous configuration
          for (let i = 0; i < node.devices_source_configured.length; ++i) {
            $("#node-input-rule-container").editableList(
              "addItem",
              node.devices_source_configured[i],
            );
          }
        })
        .catch(() => {
          node._devices_loaded = false;
          console.log("Failed to retrieve devices from device manager");
        });
    },
    oneditsave: function () {
      let node = this;

      switch ($("#node-input-device_source").val()) {
        case "configured":
          node.devices_source_dynamic = "";

          // skip save the devices due to problem with the device manager
          // communication
          if (!node._devices_loaded) {
            console.log("Skipping save the devices");
            return;
          }
          // rebuilt the list with the devices ids
          node.devices_source_configured = [];
          let entries = $("#node-input-rule-container").editableList("items");
          entries.each(function (i) {
            let userLabel = this.find("#node-input-device_source_id").val();
            let entry = $("#node-input-list_devices_id").find(
              'option[value="' + userLabel + '"]',
            );
            if (entry) {
              let deviceId = entry.attr("data-value");
              if (deviceId) {
                node.devices_source_configured.push(deviceId);
              }
            }
          });
          break;
        case "self":
          node.devices_source_configured = [""];
          node.devices_source_dynamic = "";
          break;
        case "dynamic":
          node.devices_source_configured = [""];
          break;
      }
    },
  });

  function nodeDeviceOut_displayDeviceSourceElement() {
    let deviceSource = $("#node-input-device_source");
    let devicesSourceConfigured = $("#node-input-configured");
    let devicesSourceDynamic = $("#node-input-dynamic");

    switch (deviceSource.val()) {
      case "self":
        devicesSourceConfigured.hide();
        devicesSourceDynamic.hide();
        break;
      case "configured":
        devicesSourceConfigured.show();
        devicesSourceDynamic.hide();
        break;
      case "dynamic":
        devicesSourceConfigured.hide();
        devicesSourceDynamic.show();
        break;
    }
  }
</script>
